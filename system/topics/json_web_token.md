It's true that the quote highlights important security considerations, and the advice given is generally sound. Let's break down why, and what the alternatives are:

### Is this true?

Yes, the core message of the quote is absolutely true and represents a fundamental principle of API security: **Never trust data sent directly from the client.**

Here's why passing `userId` or timestamps directly from the client in the body or query parameters is a "red flag":

* **Client-Side Manipulation:** Anyone with basic knowledge of web development tools can easily modify data sent from their browser (e.g., changing a `userId` from their own to someone else's, or manipulating timestamps). If your API relies on these client-provided values for critical operations (like authorizing actions for a specific user or determining data validity based on time), it becomes vulnerable to unauthorized access, data corruption, or other malicious activities.
* **Authentication vs. Authorization:** The client is responsible for *authenticating* (proving who they are), but the server is responsible for *authorizing* (deciding what they are allowed to do). If the client tells the server "I am user X," and the server trusts that implicitly, then there's no real authorization happening.
* **Integrity:** Data integrity is compromised if the server accepts client-provided values for things that should be controlled or generated server-side.

### If I don't pass this then what do I pass instead?

The quote correctly points out the solutions:

* **User ID (`userId`):**
    * **Session:** In a traditional session-based authentication system, when a user logs in, the server creates a session and stores information about the user (including their `userId`) on the server. A session ID (a unique, typically long and random string) is then sent to the client (usually as a cookie). For subsequent requests, the client sends this session ID, and the server uses it to look up the user's information from the stored session data. The `userId` is never explicitly sent by the client after the initial login.
    * **JWT (JSON Web Token):** This is a more modern, stateless approach. After a user authenticates, the server generates a JWT containing claims (information) about the user, including their `userId`. This token is then sent to the client. For subsequent requests, the client includes this JWT (typically in an `Authorization` header as a Bearer token). The server then *verifies* the JWT's signature (to ensure it hasn't been tampered with) and *extracts* the `userId` directly from the token. The client is still sending the token, but the server trusts the data *within* the token because it's cryptographically signed by the server itself.

* **Timestamps:**
    * **Server-Generated:** Any timestamp that is critical for business logic or security (e.g., creation time of a record, last updated time, expiration time of a link) should *always* be generated by the server at the moment the event occurs. This ensures accuracy and prevents manipulation.
    * **Client-Side Use (Informational Only):** If a client needs to display a timestamp (e.g., "message sent at X"), it can receive it from the server. If the client generates a timestamp for a *local* event (e.g., "user started typing at X client time"), that's generally fine as long as the server doesn't rely on it for critical business logic or security decisions.

### What is JWT?

**JWT stands for JSON Web Token.**

It's a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is digitally signed using a JSON Web Signature (JWS).

Here's a breakdown of what that means:

1.  **Compact and URL-safe:** JWTs are designed to be small enough to be sent in HTTP headers or URL query parameters.
2.  **JSON Object:** The "payload" of a JWT is a JSON object, which can contain various "claims."
3.  **Claims:** Claims are statements about an entity (typically the user) and additional metadata. Common claims include:
    * `iss` (issuer): Who issued the token.
    * `sub` (subject): The principal the token refers to (e.g., `userId`).
    * `aud` (audience): Who the token is intended for.
    * `exp` (expiration time): The time after which the token is no longer valid.
    * `iat` (issued at time): The time at which the token was issued.
    * Custom claims: You can add your own application-specific data (e.g., user roles, permissions).
4.  **Digitally Signed:** This is the crucial security feature. A JWT consists of three parts, separated by dots (`.`):
    * **Header:** Contains metadata about the token, such as the type of token (JWT) and the signing algorithm being used (e.g., HMAC SHA256 or RSA).
    * **Payload:** The JSON object containing the claims.
    * **Signature:** This is created by taking the encoded header, the encoded payload, a secret key (known only to the server), and the signing algorithm. The signature is used to verify that the sender of the JWT is who it claims to be and that the message hasn't been changed along the way.

**How it works in practice (Authentication with JWT):**

1.  **Authentication:** The user sends their credentials (username/password) to the server.
2.  **Token Generation:** If the credentials are valid, the server generates a JWT. It puts the `userId` and other relevant claims into the payload, signs it with a secret key, and sends the JWT back to the client.
3.  **Token Storage:** The client typically stores the JWT in `localStorage` or `sessionStorage` in the browser (or securely in a mobile app).
4.  **Subsequent Requests:** For every subsequent API request that requires authentication, the client includes the JWT in the `Authorization` header (e.g., `Authorization: Bearer <your_jwt_token>`).
5.  **Token Verification:** When the server receives a request with a JWT, it first verifies the signature of the token using the same secret key. If the signature is invalid, it means the token was tampered with or issued by an unauthorized party, and the request is rejected. If the signature is valid, the server trusts the claims within the payload, including the `userId`, and can use them for authorization.

**Advantages of JWTs:**

* **Statelessness:** The server doesn't need to store session data for each user. This makes scaling easier, as any server can verify any token.
* **Decentralization:** Useful in microservice architectures where different services might need to verify the same token.
* **Efficiency:** Can be more efficient as less data needs to be exchanged between client and server once the token is issued.

**Disadvantages of JWTs:**

* **Revocation:** Revoking a JWT before its expiration can be challenging in a purely stateless system. Strategies like blacklisting (maintaining a list of revoked tokens) or shorter expiration times are often employed.
* **Token Size:** If too many claims are added, the token can become large, increasing request overhead.
* **Security of Secret Key:** If the secret key used to sign the tokens is compromised, an attacker can forge tokens.

In summary, the advice in the quote is solid. Prioritizing server-side control over critical data like `userId` and timestamps, and leveraging secure mechanisms like sessions or JWTs, is fundamental to building robust and secure APIs.